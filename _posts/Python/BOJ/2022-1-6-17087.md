--- 
layout: post
title: "[Python] 파이썬 백준 17087 숨바꼭질 6"
author: Woohyun Kwon
categories: Python
tags: [Python, 파이썬, 백준, 알고리즘, 수학]
---

## 문제
수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 $A_1, A_2, ..., A_N$에 있다.

수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.

모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.

## 입력
첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.

## 출력
가능한 D값의 최댓값을 출력한다.

## 예제 입력 1 
    3 3
    1 7 11
## 예제 출력 1 
    2
## 예제 입력 2 
    3 81
    33 105 57
## 예제 출력 2 
    24

## 코드

```python
import sys

def gcd(x,y): # 최대공약수를 유클리드 호제법으로 구함
  while y:
    x, y = y, x % y
  return x

N, S = map(int,sys.stdin.readline().split())
bro = list(map(int,sys.stdin.readline().split())) # 동생들 위치
dist = list(set(abs(bro[i]-S) for i in range(N))) # 동생들과 수빈이와의 거리
D = min(dist) # 동생들과 수빈이와의 거리의 최솟값 

for i in range(len(dist)):
  D = gcd(dist[i], D)

print(D)
```

마지막에 최대공약수`D = gcd(dist[i], D)`를 구하는 부분만 살펴보자. 수빈이는 `X+D` 또는 `X-D`로 이동할 수 있기 때문에 단순히 수빈이와 동생들과의 거리의 최솟값 만큼만 이동하면 모든 동생과 만날 수 없다. 예를들어, 동생들과 수빈이의 위치가 다음과 같다고 하자.

|      | 동생1 | 동생2 | 수빈 | 동생3 | ... |
|:----:|:-----:|:----:|:----:|:-----:|:---:|
| 위치 |   2   |   4  |  6   |   9   |     |

그러면 동생과 수빈이의 거리의 최솟값은 2(수빈-동생2)이지만 수빈이의 위치(6)에서 2만큼 이동해도 동생3(9)과 만날 수 없다. 그래서 수빈이와 동생들과의 거리의 최솟값과 동생들과의 거리의 최대공약수`D = gcd(dist[i], D)`가 수빈이가 이동할 수 있는 거리의 최대값 `D`가 된다.

## 참고

[유클리드 호제법]()

## 출처

[백준 17087 숨바꼭질 6](https://www.acmicpc.net/problem/17087)